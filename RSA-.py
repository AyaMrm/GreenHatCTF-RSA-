

from sympy import factorint 

def extended_gcd(a, b):
    if a == 0:
        return (b, 0, 1)
    gcd, x1, y1 = extended_gcd(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    return (gcd, x, y)

def mod_inverse(e, phi):
    gcd, x, y = extended_gcd(e, phi)
    if gcd != 1:
        raise ValueError(f"L'inverse modulaire n'existe pas pour e = {e} et phi = {phi}")
    return x % phi

# vous pouvais utiliser ce script pour factoriser le n ou bien utliser autre tools comme FactorDB, dcode ou yafu car il prend bcp de temps 

'''
nombre = 370751684265766316907333907341149482412261895934374547578820282679356354614240822152667923511847084298685379359365552456565272398641769646054622777278706740882604027100370994650791288854213996021632419521841919826876670191072051571016388506546876747758038000817338924559325241097846911434150509289444613578717

facteurs = factorint(nombre)

print(f"Les facteurs de {nombre} sont :")
for facteur, puissance in facteurs.items():
    print(f"{facteur}^{puissance}")
'''

p= 19046009898340906108230036578905711038606215584969197404625982875498239003679569742638002651900390436997512421856668966396521022800749265113945474513221913
q= 19466107927312503269573168951189091141292037550966688295256699352527943796127862417666000170874869315225618130110778543609608258231150023979638769176625509
n = 370751684265766316907333907341149482412261895934374547578820282679356354614240822152667923511847084298685379359365552456565272398641769646054622777278706740882604027100370994650791288854213996021632419521841919826876670191072051571016388506546876747758038000817338924559325241097846911434150509289444613578717

phi = (p - 1) * (q - 1)  # Fonction d'Euler
e = 222847652665331147527218908740477700885184853253737972762409567278186248047609305472656088270566185077669977832923633259548766026426746485674931453748380689304592682304808040615629278759462493287812434775375636448206116249375766785865641517642759163086703786226679046657116795834230224591559795506030621733509
c = 174778556623163006176936508837311561788617312070792084548551504355950335351290823262269859612659353942636686535926925864699264725830067870019884477341081372419154746842025378737705814515190511382398420977362101820555451914345440502858717633225742238349970930963869172124294290801848275597629651167673023982830

inverse = mod_inverse(e, phi)

def rsa_decrypt(c, d, n):
    # m = (c^d) % n
    m = pow(c, d, n)
    return m



def number_to_text(number):
    text = ""
    while number > 0:
        char_code = number % 256
        text = chr(char_code) + text
        number //= 256 
    return text

d = inverse 

message_dechiffre = rsa_decrypt(c, d, n)

text = number_to_text(message_dechiffre)
print(f"Le texte est : '{text}'")


def inverser_message(message):
    
    message_inverse = message[::-1]
    return message_inverse

message_inverse = inverser_message(text)
print("Message inversÃ© :", message_inverse)
